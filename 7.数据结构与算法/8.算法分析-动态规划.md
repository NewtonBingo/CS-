## 动态规划
动态规划（Dynamic Programming）是一种解决多阶段决策过程最优化问题的算法。它在计算机科学、运筹学、控制论等领域有广泛应用。动态规划的基本思想是将原问题划分为若干个子问题，先求解子问题的解，再由子问题的解推导出原问题的解。它通常适用于有重叠子问题和最优子结构性质的问题，可以避免重复计算，提高算法的效率。
### 核心思想
动态规划问题的核心思想是将原问题划分为若干个子问题，并先求解子问题的解，再由子问题的解推导出原问题的解。其主要思路是将问题转化为一个递推式，然后用递推的方式求解。其主要步骤包括以下几个：
- 定义状态：定义子问题的状态，通常用一个或多个变量表示状态。
- 定义状态转移方程：根据问题的特点，定义状态之间的转移方程，通常是一个递推式。
- 确定边界状态：确定问题的边界状态，即最简单的子问题的解。
- 自底向上求解：根据递推式和边界状态，自底向上求解子问题的解，直到求解出原问题的解。

动态规划的优势在于可以避免重复计算，提高算法的效率。但是，动态规划也有一些限制，例如需要满足最优子结构性质和重叠子问题性质。此外，在实际应用中，动态规划的状态定义、状态转移方程和边界状态的确定都需要仔细思考，才能得到正确的结果。
### LCS最长公共子序列问题
``` cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1005;

int f[N][N]; // f[i][j]表示s1的前i个字符和s2的前j个字符的LCS长度

int main()
{
    string s1, s2;
    cin >> s1 >> s2;
    int n = s1.size(), m = s2.size();

    // 确定边界状态
    for (int i = 0; i <= n; i++) f[i][0] = 0;
    for (int j = 0; j <= m; j++) f[0][j] = 0;

    // 自底向上求解
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (s1[i - 1] == s2[j - 1])
                f[i][j] = f[i - 1][j - 1] + 1; // 状态转移方程
            else
                f[i][j] = max(f[i - 1][j], f[i][j - 1]); // 状态转移方程

    cout << f[n][m] << endl; // 输出LCS长度

    return 0;
}

```
这段代码使用了一个二维数组f来记录最长公共子序列的长度。首先输入两个字符串s1和s2，然后分别记录它们的长度n和m。接着，初始化边界状态，即f[i][0]和f[0][j]均为0。最后，使用两重循环遍历所有状态，根据状态转移方程来更新状态，得到最终的LCS长度f[n][m]。

该代码实现中，每个状态的更新只和前一个状态有关，因此不需要使用滚动数组进行优化。但是，在实际应用中，LCS问题通常需要使用滚动数组等优化方法来减少空间复杂度。
