## 算法
算法是指用于解决问题或完成任务的一组有序的操作步骤。它可以用来处理各种类型的数据，包括数字、文本、图像和音频等。在计算机科学领域中，算法是解决问题和编写程序的基本工具。
### 算法分类
算法可以按照不同的分类方式进行分类，以下是常见的几种分类方式：
- 按照问题类型分类：算法可以按照处理的问题类型进行分类，例如排序算法、搜索算法、图论算法、动态规划算法等。
- 按照算法策略分类：算法可以按照解决问题的策略进行分类，例如贪心算法、分治算法、动态规划算法、回溯算法等。
- 按照数据结构分类：算法可以按照所使用的数据结构进行分类，例如链表算法、树算法、堆算法、哈希算法等。
- 按照复杂度分类：算法可以按照时间复杂度和空间复杂度进行分类，例如O(1)、O(log n)、O(n)、O(n log n)、O(n^2)等。
- 按照性质分类：算法可以按照性质进行分类，例如稳定排序算法和非稳定排序算法、串匹配算法和文本压缩算法等。

常见算法分类：
- 排序算法：用于对数据进行排序的算法，如冒泡排序、快速排序和归并排序等。
- 查找算法：用于在数据集合中查找特定元素的算法，如二分查找和哈希查找等。
- 图论算法：用于处理图形数据的算法，如最短路径算法、最小生成树算法和拓扑排序算法等。
- 字符串算法：用于处理文本数据的算法，如字符串匹配算法和字符串压缩算法等。
- 机器学习算法：用于处理大规模数据的算法，如支持向量机、神经网络和决策树等。

### 算法思想
![image](https://user-images.githubusercontent.com/107925483/231052568-b88d61b1-f93d-4d42-812e-e335d8389ea1.png)
### 查找算法
查找算法（Search Algorithm）是一种用于在一组数据中寻找指定数据的方法。查找算法通常用于在大量数据中查找目标数据，并返回目标数据的位置或其他相关信息。
![image](https://user-images.githubusercontent.com/107925483/231053339-52f63b64-cb34-4eef-952c-3d5850abac89.png)
![image](https://user-images.githubusercontent.com/107925483/231053990-3751d5fd-4670-4ba6-b787-95bf0661f297.png)
#### 线性表的查找
线性查找算法（Linear Search Algorithm）：也称为顺序查找算法。它从数据集的第一个元素开始逐个比较，直到找到目标元素或遍历完整个数据集。
静态查找是指在不改变数据集的情况下，通过某种查找算法查找指定数据的过程。静态查找适用于数据集不经常变化或者只需查找一次的情况。
##### 线性查找算法（Linear Search Algorithm）
也称为顺序查找算法。它从数据集的第一个元素开始逐个比较，直到找到目标元素或遍历完整个数据集。  
数组实现：
``` c
#include <stdio.h>

// 线性查找函数，传入数据集、数据集长度、目标元素，返回目标元素在数据集中的位置（从0开始计数）
int linear_search(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {  // 依次遍历数据集中的每个元素
        if (arr[i] == target) {  // 如果找到目标元素，返回它在数据集中的位置
            return i;
        }
    }
    return -1;  // 如果遍历完整个数据集都没有找到目标元素，返回-1表示未找到
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13};  // 定义一个整数数组作为数据集
    int n = sizeof(arr) / sizeof(int);  // 计算数据集的长度
    int target = 7;  // 定义要查找的目标元素
    int pos = linear_search(arr, n, target);  // 调用线性查找函数查找目标元素
    if (pos != -1) {  // 如果找到了目标元素，输出它在数据集中的位置
        printf("Target %d is at position %d.\n", target, pos);
    } else {  // 如果未找到目标元素，输出未找到的信息
        printf("Target %d is not found.\n", target);
    }
    return 0;
}

```
链表实现：
``` c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点结构体
typedef struct node {
    int val;  // 节点的值
    struct node *next;  // 指向下一个节点的指针
} Node;

// 定义链表查找函数，传入链表头节点指针、目标元素，返回目标元素在链表中的位置（从0开始计数）
int linked_list_search(Node *head, int target) {
    int pos = 0;  // 记录当前节点在链表中的位置，初始化为0
    Node *p = head;  // 从链表头部开始遍历
    while (p != NULL) {  // 如果当前节点不为空
        if (p->val == target) {  // 如果找到目标元素，返回它在链表中的位置
            return pos;
        }
        pos++;  // 更新当前节点在链表中的位置
        p = p->next;  // 将当前节点指针移动到下一个节点
    }
    return -1;  // 如果遍历完整个链表都没有找到目标元素，返回-1表示未找到
}

int main() {
    // 创建链表节点，并将它们按顺序连接起来
    Node *head = NULL;  // 链表头指针初始化为空
    for (int i = 0; i < 7; i++) {
        Node *new_node = (Node*)malloc(sizeof(Node));  // 创建新节点
        new_node->val = i * 2 + 1;  // 设置节点值
        new_node->next = head;  // 将新节点插入链表头部
        head = new_node;  // 更新链表头指针
    }

    int target = 7;  // 定义要查找的目标元素
    int pos = linked_list_search(head, target);  // 调用链表查找函数查找目标元素
    if (pos != -1) {
      //1.判断是否查找成功
      printf("Target %d is at position %d\n", target, pos);
    } else {
      printf("Target %d is not found\n", target);
    }
    
    // 释放链表内存
    Node *p = head;
    while (p != NULL) {
        Node *tmp = p;
        p = p->next;
        free(tmp);
    }

    return 0;
}
    
```
##### 二分查找
二分查找（Binary Search）是一种针对有序数组的高效查找算法。二分查找的基本思想是将数组从中间分成两个部分，如果目标值与中间值相等，则直接返回；否则，如果目标值比中间值小，则在左半部分继续查找；如果目标值比中间值大，则在右半部分继续查找。重复这个过程，直到找到目标值或者左右部分不能再分为止。

- 二分查找算法的时间复杂度为O(log n)，相比于线性查找的O(n)，效率更高。不过二分查找需要先对数组进行排序，这是一个比较耗时的操作，因此适用于静态数据，即数据不经常变化的情况下。
- 二分查找的实现依赖于数组元素的随机访问，而链表不支持随机访问，因此链表并不是二分查找的最优数据结构。
``` c
//迭代的方式
#include <stdio.h>

// 定义二分查找函数，传入有序数组、数组长度、目标值，返回目标值在数组中的位置（从0开始计数），如果不存在则返回-1
int binary_search(int arr[], int len, int target) {
    int left = 0;  // 定义左指针，指向数组起始位置
    int right = len - 1;  // 定义右指针，指向数组末尾位置
    while (left <= right) {  // 如果左右指针没有重叠，继续查找
        int mid = (left + right) / 2;  // 计算中间位置
        if (arr[mid] == target) {  // 如果中间位置的值等于目标值，直接返回
            return mid;
        } else if (arr[mid] > target) {  // 如果中间位置的值比目标值大，继续在左半部分查找
            right = mid - 1;  // 更新右指针
        } else {  // 如果中间位置的值比目标值小，继续在右半部分查找
            left = mid + 1;  // 更新左指针
        }
    }
    return -1;  // 如果左右指针重叠仍未找到目标值，返回-1表示不存在
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13};  // 定义有序数组
    int len = sizeof(arr) / sizeof(int);  // 计算数组长度
    int target = 7;  // 定义要查找的目标值
    int pos = binary_search(arr, len, target);  // 调用二分查找函数查找目标值
    if (pos != -1) {  // 如果查找成功，输出目标值在数组中的位置
        printf("Target %d is at position %d\n", target, pos);
    } else {  // 如果查找失败，输出不存在提示
        printf("Target %d is not found\n", target);
    }
    return 0;
}

```

``` c
//递归的方式，注意如果数据量，有可能出现栈溢出的问题
#include <stdio.h>

// 定义二分查找函数，传入有序数组、起始位置、结束位置、目标值，返回目标值在数组中的位置（从0开始计数），如果不存在则返回-1
int binary_search_recursive(int arr[], int left, int right, int target) {
    if (left > right) {  // 如果左右指针重叠仍未找到目标值，返回-1表示不存在
        return -1;
    }
    int mid = (left + right) / 2;  // 计算中间位置
    if (arr[mid] == target) {  // 如果中间位置的值等于目标值，直接返回
        return mid;
    } else if (arr[mid] > target) {  // 如果中间位置的值比目标值大，继续在左半部分查找
        return binary_search_recursive(arr, left, mid - 1, target);  // 递归调用自身，在左半部分查找
    } else {  // 如果中间位置的值比目标值小，继续在右半部分查找
        return binary_search_recursive(arr, mid + 1, right, target);  // 递归调用自身，在右半部分查找
    }
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11, 13};  // 定义有序数组
    int len = sizeof(arr) / sizeof(int);  // 计算数组长度
    int target = 7;  // 定义要查找的目标值
    int pos = binary_search_recursive(arr, 0, len - 1, target);  // 调用二分查找函数查找目标值
    if (pos != -1) {  // 如果查找成功，输出目标值在数组中的位置
        printf("Target %d is at position %d\n", target, pos);
    } else {  // 如果查找失败，输出不存在提示
        printf("Target %d is not found\n", target);
    }
    return 0;
}

```
