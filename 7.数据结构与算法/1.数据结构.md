## 数据结构分类
数据结构通常可以分为以下几类：
- 线性数据结构：线性数据结构是一种数据元素按线性顺序排列的数据结构。它包括数组、链表、栈、队列等。
- 树形数据结构：树形数据结构是一种非线性的数据结构，由一个根节点和若干个子树构成，每个子树又可以由若干个子树构成。它包括二叉树、二叉搜索树、平衡树等。
- 图形数据结构：图形数据结构是一种由节点和边构成的非线性结构，用于描述实体间的关系。它包括有向图、无向图、加权图等。
- 散列表：散列表是一种根据关键字直接访问内存位置的数据结构，可以快速地插入、删除和查找数据。它包括哈希表、字典等。
- 其他数据结构：除了以上几种数据结构之外，还有一些其他的数据结构，例如堆、优先队列、并查集等。它们通常用于特定的算法或数据处理问题中。
每种数据结构都有其特点和适用场景，选择合适的数据结构可以大大提高程序的效率和性能。
### 线性数据结构
![image](https://user-images.githubusercontent.com/107925483/230784984-e1ffc375-7105-4dd0-aaa5-b161bbf43075.png)
#### 线性表的顺序表示（数组）
线性表的顺序表示通常采用数组来实现，其中数组中的每个元素表示线性表中的一个数据元素。
具体地，设线性表的元素为$a_1,a_2,...,a_n$，则它们在数组中的顺序表示为$a[1],a[2],...,a[n]$。其中，$a[1]$表示线性表的第一个元素，$a[2]$表示线性表的第二个元素，以此类推，$a[n]$表示线性表的最后一个元素。
当然，为了方便地对线性表进行操作，通常会在数组中预留一些空间，以保证在插入和删除操作时可以方便地进行元素的移动和调整。同时，为了记录线性表中的元素个数，也需要在数组中记录一个变量$length$，表示当前线性表中的元素个数。这样，在进行插入、删除、查找等操作时，可以通过$length$来判断操作的合法性，并在操作后更新$length$的值。
``` c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 100   // 线性表最大长度

typedef struct {
    int data[MAXSIZE];  // 存储线性表元素的数组
    int length;         // 线性表当前长度
} SqList;               // 线性表的结构体定义

// 初始化线性表
void InitList(SqList *L) {
    L->length = 0;
}

// 插入元素
int ListInsert(SqList *L, int i, int e) {
    if (i < 1 || i > L->length + 1) {
        return 0;  // i值不合法
    }
    if (L->length == MAXSIZE) {
        return 0;  // 线性表已满
    }
    for (int j = L->length; j >= i; j--) {
        L->data[j] = L->data[j-1];  // 将第i个位置及以后的元素后移一位
    }
    L->data[i-1] = e;  // 插入新元素e
    L->length++;       // 线性表长度加1
    return 1;
}

// 删除元素
int ListDelete(SqList *L, int i, int *e) {
    if (i < 1 || i > L->length) {
        return 0;  // i值不合法
    }
    *e = L->data[i-1];  // 将被删除元素的值赋给e
    for (int j = i; j < L->length; j++) {
        L->data[j-1] = L->data[j];  // 将第i个位置及以后的元素前移一位
    }
    L->length--;  // 线性表长度减1
    return 1;
}

// 查找元素
int ListSearch(SqList *L, int e) {
    for (int i = 0; i < L->length; i++) {
        if (L->data[i] == e) {
            return i+1;  // 返回元素在线性表中的位置
        }
    }
    return 0;  // 元素不在线性表中
}

// 打印线性表
void ListPrint(SqList *L) {
    for (int i = 0; i < L->length; i++) {
        printf("%d ", L->data[i]);
    }
    printf("\n");
}

int main() {
    SqList L;
    InitList(&L);
    ListInsert(&L, 1, 1);
    ListInsert(&L, 2, 3);
    ListInsert(&L, 3, 5);
    ListPrint(&L);  // 输出：1 3 5
    int e;
    ListDelete(&L, 2, &e);
    printf("%d\n", e);  // 输出：3
    ListPrint(&L);      // 输出：1 5
    int pos = ListSearch(&L, 5);
    printf("%d\n", pos);  // 输出
}
```
假溢出  
假溢出指的是在顺序队列的操作过程中，由于入队和出队的位置相对靠近，导致队列实际上并没有满，但是队尾指针和队头指针相遇了，给人一种队列已满的假象，称为假溢出。  

假溢出的出现是由于顺序队列采用的是循环数组的存储方式，队尾指针和队头指针是在数组中循环移动的。当队列中的元素满时，队尾指针再往前移动一个位置就会与队头指针重合，此时队列的空间并没有完全利用，但是由于队尾指针和队头指针重合，无法再插入新元素，因此给人一种假象。  

避免假溢出的方法是在队列中保留一个元素的空间，即循环队列中留出一个元素的空间不存储数据，用来判断队列是否满。这样，当队列中的元素数量达到数组长度时，队尾指针和队头指针就不会重合，队列也不会出现假溢出的情况。  
#### 线性表的链式表示（链表）
线性表的链式表示是指使用指针来描述线性表中各个数据元素之间的逻辑关系，链式表示包括单链表、双向链表、循环链表等多种形式。其中，单链表是最常见的一种链式表示方式。

在单链表中，每个数据元素由两部分组成：数据域和指针域。数据域存储数据元素的值，指针域则指向下一个数据元素的地址。最后一个元素的指针域指向空地址NULL，表示链表的结束。  
后插法
``` c
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

//插入某个结点
void insertNodeAtEnd(ListNode **head, int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode->val = val;
    newNode->next = NULL;
    
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    
    ListNode* tailNode = *head;
    while (tailNode->next != NULL) {
        tailNode = tailNode->next;
    }
    tailNode->next = newNode;
}

//删除某个结点
void deleteNode(ListNode **head, int val) {
    ListNode* delNode = *head;
    ListNode* prevNode = NULL;

    // 如果要删除的是头节点
    if (delNode != NULL && delNode->val == val) {
        *head = delNode->next;
        free(delNode);
        return;
    }

    while (delNode != NULL && delNode->val != val) {
        prevNode = delNode;
        delNode = delNode->next;
    }

    if (delNode == NULL) {
        return;  // 没有找到要删除的节点
    }

    prevNode->next = delNode->next;
    free(delNode);
}

//查找某个值
ListNode* findNode(ListNode* head, int val) {
    ListNode* currNode = head;
    while (currNode != NULL) {
        if (currNode->val == val) {
            return currNode;
        }
        currNode = currNode->next;
    }
    return NULL;
}

int main() {
    ListNode* head = NULL;
    insertNodeAtEnd(&head, 1);
    insertNodeAtEnd(&head, 2);
    insertNodeAtEnd(&head, 3);
    // 遍历链表
    ListNode* currNode = head;
    while (currNode != NULL) {
        printf("%d ", currNode->val);
        currNode = currNode->next;
    }
    
    deleteNode(&head, 2);
    ListNode* node = findNode(head, 3);
    if (node == NULL) {
        printf("Not found.\n");
    } else {
        printf("Found: %d\n", node->val);
    }
    return 0;
}


```
前插法
``` c
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

ListNode* insertNode(ListNode* head, int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode->val = val;
    newNode->next = head;
    head = newNode;
    return head;
}

int main() {
    ListNode* head = NULL;
    // 初始化链表

    head = insertNode(head, 1);

    return 0;
}

```
### 操作受限的线性表（栈、队列）
![image](https://user-images.githubusercontent.com/107925483/230785558-a5bbc683-25e7-4982-93c5-35a98e6ca3c4.png)
#### 栈（先进后出）
##### 顺序栈
使用数组实现栈时，我们需要记录栈顶元素的下标，以便在入栈和出栈操作时更新栈顶元素的位置
``` c
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

Stack* createStack() {
    Stack* s = (Stack*)malloc(sizeof(Stack));
    s->top = -1;
    return s;
}

bool isEmpty(Stack* s) {
    return s->top == -1;
}

bool isFull(Stack* s) {
    return s->top == MAX_SIZE - 1;
}

void push(Stack* s, int x) {
    if (isFull(s)) {
        printf("Error: stack is full.\n");
        return;
    }
    s->data[++s->top] = x;
}

int pop(Stack* s) {
    if (isEmpty(s)) {
        printf("Error: stack is empty.\n");
        return -1;
    }
    return s->data[s->top--];
}

int top(Stack* s) {
    if (isEmpty(s)) {
        printf("Error: stack is empty.\n");
        return -1;
    }
    return s->data[s->top];
}

int size(Stack* s) {
    return s->top + 1;
}

int main() {
    Stack* s = createStack();

    push(s, 1);
    push(s, 2);
    push(s, 3);

    printf("Size of stack: %d\n", size(s));
    printf("Top element: %d\n", top(s));
    printf("Pop element: %d\n", pop(s));
    printf("Pop element: %d\n", pop(s));
    printf("Pop element: %d\n", pop(s));
    printf("Size of stack: %d\n", size(s));

    free(s);
    return 0;
}

```
##### 链式栈
用链表实现栈相比于用数组实现栈，不需要考虑数组大小的限制，因此更加灵活，可以根据实际情况动态调整栈的大小
``` c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int data;
    struct node *next;
} Node;

typedef struct {
    Node *top;
    int size;
} Stack;

Stack *createStack() {
    Stack *s = (Stack *) malloc(sizeof(Stack));
    s->top = NULL;
    s->size = 0;
    return s;
}

int isEmpty(Stack *s) {
    return s->size == 0;
}

void push(Stack *s, int data) {
    Node *newNode = (Node *) malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = s->top;
    s->top = newNode;
    s->size++;
}

int pop(Stack *s) {
    if (isEmpty(s)) {
        printf("Error: Stack is empty.\n");
        return -1;
    }
    int data = s->top->data;
    Node *temp = s->top;
    s->top = s->top->next;
    free(temp);
    s->size--;
    return data;
}

int top(Stack *s) {
    if (isEmpty(s)) {
        printf("Error: Stack is empty.\n");
        return -1;
    }
    return s->top->data;
}

int size(Stack *s) {
    return s->size;
}

int main() {
    Stack *s = createStack();
    push(s, 1);
    push(s, 2);
    push(s, 3);
    printf("Size of stack: %d\n", size(s));
    printf("Top element: %d\n", top(s));
    while (!isEmpty(s)) {
        printf("Popped element: %d\n", pop(s));
    }
    printf("Size of stack: %d\n", size(s));
    free(s);
    return 0;
}

```
##### 栈和递归  
栈和递归之间有着紧密的联系。在递归过程中，每次函数调用都会将当前函数的状态保存到栈中，包括函数的参数、局部变量以及程序计数器等信息，直到递归结束后，这些信息才会依次弹出栈。因此，可以将递归过程看作是一系列栈帧的压入和弹出。  

递归函数的本质是对同一个问题的重复求解，因此，可以用栈来实现递归函数，避免使用系统栈带来的内存消耗和运行时间开销。例如，可以将递归函数转化为非递归函数，使用显式栈来保存中间结果。下面是一个例子：
``` c
// 递归函数
int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}

// 非递归函数
int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        int c = a + b;
        a = b;
        b = c;
    }
    return b;
}

```
#### 队列（先进先出）
队列是一种数据结构，它遵循先进先出（FIFO）的原则。与栈不同，队列只允许在队列的前端进行删除操作，在队列的后端进行插入操作。队列通常有两个指针：队首指针和队尾指针，队首指针指向队列中的第一个元素，队尾指针指向队列中的最后一个元素。  

队列的基本操作包括入队（enqueue）和出队（dequeue）。入队操作将一个元素插入队列的尾部，出队操作删除队列的头部元素并返回该元素。  

队列可以用数组或链表来实现。数组实现的队列称为顺序队列，链表实现的队列称为链式队列。顺序队列的优点是随机访问速度快，但插入和删除操作需要移动大量元素，时间复杂度为O(n)；链式队列的优点是插入和删除操作只需修改指针，时间复杂度为O(1)，但访问任意元素需要遍历整个队列，时间复杂度为O(n)。
##### 顺序队列
``` c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100 // 队列最大长度

// 队列结构体
typedef struct {
    int data[MAX_SIZE]; // 队列元素
    int front; // 队头指针
    int rear; // 队尾指针
} SeqQueue;

// 初始化队列
void InitQueue(SeqQueue *queue) {
    queue->front = 0;
    queue->rear = 0;
}

// 判断队列是否为空
int IsEmpty(SeqQueue *queue) {
    return queue->front == queue->rear;
}

// 判断队列是否已满
int IsFull(SeqQueue *queue) {
    return (queue->rear + 1) % MAX_SIZE == queue->front;
}

// 入队操作
void EnQueue(SeqQueue *queue, int elem) {
    if (IsFull(queue)) {
        printf("Queue is full!\n");
        return;
    }
    queue->data[queue->rear] = elem;
    queue->rear = (queue->rear + 1) % MAX_SIZE;
}

// 出队操作
int DeQueue(SeqQueue *queue) {
    if (IsEmpty(queue)) {
        printf("Queue is empty!\n");
        return -1;
    }
    int elem = queue->data[queue->front];
    queue->front = (queue->front + 1) % MAX_SIZE;
    return elem;
}

// 获取队列长度
int GetQueueLength(SeqQueue *queue) {
    return (queue->rear - queue->front + MAX_SIZE) % MAX_SIZE;
}

// 获取队头元素
int GetFront(SeqQueue *queue) {
    if (IsEmpty(queue)) {
        printf("Queue is empty!\n");
        return -1;
    }
    return queue->data[queue->front];
}

// 清空队列
void ClearQueue(SeqQueue *queue) {
    queue->front = 0;
    queue->rear = 0;
}

// 销毁队列
void DestroyQueue(SeqQueue *queue) {
    free(queue);
}

// 遍历队列
void TraverseQueue(SeqQueue *queue) {
    if (IsEmpty(queue)) {
        printf("Queue is empty!\n");
        return;
    }
    printf("Queue elements: ");
    int i = queue->front;
    while (i != queue->rear) {
        printf("%d ", queue->data[i]);
        i = (i + 1) % MAX_SIZE;
    }
    printf("\n");
}

int main() {
    SeqQueue *queue = (SeqQueue *)malloc(sizeof(SeqQueue));
    InitQueue(queue);
    EnQueue(queue, 1);
    EnQueue(queue, 2);
    EnQueue(queue, 3);
    TraverseQueue(queue);
    printf("Queue length: %d\n", GetQueueLength(queue));
    printf("Queue front: %d\n", GetFront(queue));
    DeQueue(queue);
    TraverseQueue(queue);
    ClearQueue(queue);
    TraverseQueue(queue);
    DestroyQueue(queue);
    return 0;
}

``` c
##### 链式队列
``` c
#include <stdio.h>
#include <stdlib.h>

// 链表节点结构体
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 队列结构体
typedef struct Queue {
    Node *front;  // 队头指针
    Node *rear;   // 队尾指针
} Queue;

// 初始化队列
void initQueue(Queue *queue) {
    queue->front = NULL;
    queue->rear = NULL;
}

// 判断队列是否为空
int isEmpty(Queue *queue) {
    return queue->front == NULL;
}

// 入队
void enqueue(Queue *queue, int value) {
    Node *newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;
    if (queue->rear != NULL) {
        queue->rear->next = newNode;
    }
    queue->rear = newNode;
    if (queue->front == NULL) {
        queue->front = newNode;
    }
}

// 出队
int dequeue(Queue *queue) {
    if (isEmpty(queue)) {
        printf("Error: Queue is empty!\n");
        return -1;
    }
    int value = queue->front->data;
    Node *temp = queue->front;
    queue->front = queue->front->next;
    if (queue->front == NULL) {
        queue->rear = NULL;
    }
    free(temp);
    return value;
}

// 获取队首元素
int front(Queue *queue) {
    if (isEmpty(queue)) {
        printf("Error: Queue is empty!\n");
        return -1;
    }
    return queue->front->data;
}

// 主函数
int main() {
    Queue queue;
    initQueue(&queue);
    enqueue(&queue, 1);
    enqueue(&queue, 2);
    enqueue(&queue, 3);
    printf("front element is: %d\n", front(&queue));
    printf("dequeue element is: %d\n", dequeue(&queue));
    printf("front element is: %d\n", front(&queue));
    return 0;
}

```
顺序队列和链式队列是两种常见的队列实现方式，它们有以下几点区别：
- 存储结构不同：顺序队列使用数组来存储元素，链式队列使用链表来存储元素。
- 内存占用不同：顺序队列需要预先分配一定大小的数组空间，而链式队列则不需要。
- 队列长度限制不同：顺序队列的长度有限制，最多只能存储数组大小个元素，而链式队列的长度理论上是没有限制的。
- 入队和出队操作的时间复杂度不同：顺序队列的入队和出队操作的时间复杂度为O(1)，而链式队列的入队和出队操作的时间复杂度也为O(1)，但是由于涉及到动态内存分配和释放，实际的运行时间可能会受到内存分配和释放的影响。
- 
综上所述，顺序队列适合处理元素个数比较固定的情况，而链式队列则适合处理元素个数比较不确定的情况。同时，在入队和出队操作的频率较高时，顺序队列的性能优于链式队列。但是在需要动态增加队列长度的情况下，链式队列是更为灵活和方便的选择。




