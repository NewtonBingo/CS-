## 数据结构分类
数据结构通常可以分为以下几类：
- 线性数据结构：线性数据结构是一种数据元素按线性顺序排列的数据结构。它包括数组、链表、栈、队列等。
- 树形数据结构：树形数据结构是一种非线性的数据结构，由一个根节点和若干个子树构成，每个子树又可以由若干个子树构成。它包括二叉树、二叉搜索树、平衡树等。
- 图形数据结构：图形数据结构是一种由节点和边构成的非线性结构，用于描述实体间的关系。它包括有向图、无向图、加权图等。
- 散列表：散列表是一种根据关键字直接访问内存位置的数据结构，可以快速地插入、删除和查找数据。它包括哈希表、字典等。
- 其他数据结构：除了以上几种数据结构之外，还有一些其他的数据结构，例如堆、优先队列、并查集等。它们通常用于特定的算法或数据处理问题中。
每种数据结构都有其特点和适用场景，选择合适的数据结构可以大大提高程序的效率和性能。
### 线性数据结构
![image](https://user-images.githubusercontent.com/107925483/230784984-e1ffc375-7105-4dd0-aaa5-b161bbf43075.png)
#### 线性表的顺序表示（数组）
线性表的顺序表示通常采用数组来实现，其中数组中的每个元素表示线性表中的一个数据元素。
具体地，设线性表的元素为$a_1,a_2,...,a_n$，则它们在数组中的顺序表示为$a[1],a[2],...,a[n]$。其中，$a[1]$表示线性表的第一个元素，$a[2]$表示线性表的第二个元素，以此类推，$a[n]$表示线性表的最后一个元素。
当然，为了方便地对线性表进行操作，通常会在数组中预留一些空间，以保证在插入和删除操作时可以方便地进行元素的移动和调整。同时，为了记录线性表中的元素个数，也需要在数组中记录一个变量$length$，表示当前线性表中的元素个数。这样，在进行插入、删除、查找等操作时，可以通过$length$来判断操作的合法性，并在操作后更新$length$的值。
``` c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 100   // 线性表最大长度

typedef struct {
    int data[MAXSIZE];  // 存储线性表元素的数组
    int length;         // 线性表当前长度
} SqList;               // 线性表的结构体定义

// 初始化线性表
void InitList(SqList *L) {
    L->length = 0;
}

// 插入元素
int ListInsert(SqList *L, int i, int e) {
    if (i < 1 || i > L->length + 1) {
        return 0;  // i值不合法
    }
    if (L->length == MAXSIZE) {
        return 0;  // 线性表已满
    }
    for (int j = L->length; j >= i; j--) {
        L->data[j] = L->data[j-1];  // 将第i个位置及以后的元素后移一位
    }
    L->data[i-1] = e;  // 插入新元素e
    L->length++;       // 线性表长度加1
    return 1;
}

// 删除元素
int ListDelete(SqList *L, int i, int *e) {
    if (i < 1 || i > L->length) {
        return 0;  // i值不合法
    }
    *e = L->data[i-1];  // 将被删除元素的值赋给e
    for (int j = i; j < L->length; j++) {
        L->data[j-1] = L->data[j];  // 将第i个位置及以后的元素前移一位
    }
    L->length--;  // 线性表长度减1
    return 1;
}

// 查找元素
int ListSearch(SqList *L, int e) {
    for (int i = 0; i < L->length; i++) {
        if (L->data[i] == e) {
            return i+1;  // 返回元素在线性表中的位置
        }
    }
    return 0;  // 元素不在线性表中
}

// 打印线性表
void ListPrint(SqList *L) {
    for (int i = 0; i < L->length; i++) {
        printf("%d ", L->data[i]);
    }
    printf("\n");
}

int main() {
    SqList L;
    InitList(&L);
    ListInsert(&L, 1, 1);
    ListInsert(&L, 2, 3);
    ListInsert(&L, 3, 5);
    ListPrint(&L);  // 输出：1 3 5
    int e;
    ListDelete(&L, 2, &e);
    printf("%d\n", e);  // 输出：3
    ListPrint(&L);      // 输出：1 5
    int pos = ListSearch(&L, 5);
    printf("%d\n", pos);  // 输出
}
```
#### 线性表的链式表示（链表）
线性表的链式表示是指使用指针来描述线性表中各个数据元素之间的逻辑关系，链式表示包括单链表、双向链表、循环链表等多种形式。其中，单链表是最常见的一种链式表示方式。

在单链表中，每个数据元素由两部分组成：数据域和指针域。数据域存储数据元素的值，指针域则指向下一个数据元素的地址。最后一个元素的指针域指向空地址NULL，表示链表的结束。  
后插法
``` c
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

//插入某个结点
void insertNodeAtEnd(ListNode **head, int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode->val = val;
    newNode->next = NULL;
    
    if (*head == NULL) {
        *head = newNode;
        return;
    }
    
    ListNode* tailNode = *head;
    while (tailNode->next != NULL) {
        tailNode = tailNode->next;
    }
    tailNode->next = newNode;
}

//删除某个结点
void deleteNode(ListNode **head, int val) {
    ListNode* delNode = *head;
    ListNode* prevNode = NULL;

    // 如果要删除的是头节点
    if (delNode != NULL && delNode->val == val) {
        *head = delNode->next;
        free(delNode);
        return;
    }

    while (delNode != NULL && delNode->val != val) {
        prevNode = delNode;
        delNode = delNode->next;
    }

    if (delNode == NULL) {
        return;  // 没有找到要删除的节点
    }

    prevNode->next = delNode->next;
    free(delNode);
}

//查找某个值
ListNode* findNode(ListNode* head, int val) {
    ListNode* currNode = head;
    while (currNode != NULL) {
        if (currNode->val == val) {
            return currNode;
        }
        currNode = currNode->next;
    }
    return NULL;
}

int main() {
    ListNode* head = NULL;
    insertNodeAtEnd(&head, 1);
    insertNodeAtEnd(&head, 2);
    insertNodeAtEnd(&head, 3);
    // 遍历链表
    ListNode* currNode = head;
    while (currNode != NULL) {
        printf("%d ", currNode->val);
        currNode = currNode->next;
    }
    
    deleteNode(&head, 2);
    ListNode* node = findNode(head, 3);
    if (node == NULL) {
        printf("Not found.\n");
    } else {
        printf("Found: %d\n", node->val);
    }
    return 0;
}


```
前插法
``` c
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

ListNode* insertNode(ListNode* head, int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    newNode->val = val;
    newNode->next = head;
    head = newNode;
    return head;
}

int main() {
    ListNode* head = NULL;
    // 初始化链表

    head = insertNode(head, 1);

    return 0;
}

```
#### 操作受限的线性表（栈、队列）
##### 栈（先进后出）
使用数组实现栈时，我们需要记录栈顶元素的下标，以便在入栈和出栈操作时更新栈顶元素的位置
``` c
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

Stack* createStack() {
    Stack* s = (Stack*)malloc(sizeof(Stack));
    s->top = -1;
    return s;
}

bool isEmpty(Stack* s) {
    return s->top == -1;
}

bool isFull(Stack* s) {
    return s->top == MAX_SIZE - 1;
}

void push(Stack* s, int x) {
    if (isFull(s)) {
        printf("Error: stack is full.\n");
        return;
    }
    s->data[++s->top] = x;
}

int pop(Stack* s) {
    if (isEmpty(s)) {
        printf("Error: stack is empty.\n");
        return -1;
    }
    return s->data[s->top--];
}

int top(Stack* s) {
    if (isEmpty(s)) {
        printf("Error: stack is empty.\n");
        return -1;
    }
    return s->data[s->top];
}

int size(Stack* s) {
    return s->top + 1;
}

int main() {
    Stack* s = createStack();

    push(s, 1);
    push(s, 2);
    push(s, 3);

    printf("Size of stack: %d\n", size(s));
    printf("Top element: %d\n", top(s));
    printf("Pop element: %d\n", pop(s));
    printf("Pop element: %d\n", pop(s));
    printf("Pop element: %d\n", pop(s));
    printf("Size of stack: %d\n", size(s));

    free(s);
    return 0;
}

```
用链表实现栈相比于用数组实现栈，不需要考虑数组大小的限制，因此更加灵活，可以根据实际情况动态调整栈的大小
``` c
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
    int data;
    struct node *next;
} Node;

typedef struct {
    Node *top;
    int size;
} Stack;

Stack *createStack() {
    Stack *s = (Stack *) malloc(sizeof(Stack));
    s->top = NULL;
    s->size = 0;
    return s;
}

int isEmpty(Stack *s) {
    return s->size == 0;
}

void push(Stack *s, int data) {
    Node *newNode = (Node *) malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = s->top;
    s->top = newNode;
    s->size++;
}

int pop(Stack *s) {
    if (isEmpty(s)) {
        printf("Error: Stack is empty.\n");
        return -1;
    }
    int data = s->top->data;
    Node *temp = s->top;
    s->top = s->top->next;
    free(temp);
    s->size--;
    return data;
}

int top(Stack *s) {
    if (isEmpty(s)) {
        printf("Error: Stack is empty.\n");
        return -1;
    }
    return s->top->data;
}

int size(Stack *s) {
    return s->size;
}

int main() {
    Stack *s = createStack();
    push(s, 1);
    push(s, 2);
    push(s, 3);
    printf("Size of stack: %d\n", size(s));
    printf("Top element: %d\n", top(s));
    while (!isEmpty(s)) {
        printf("Popped element: %d\n", pop(s));
    }
    printf("Size of stack: %d\n", size(s));
    free(s);
    return 0;
}

```
![image](https://user-images.githubusercontent.com/107925483/230785558-a5bbc683-25e7-4982-93c5-35a98e6ca3c4.png)
