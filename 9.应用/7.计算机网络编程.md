## 套接字
套接字编程是一种网络编程技术，它可以让程序在不同的计算机之间进行通信。套接字编程的原理可以总结为以下几点：

- 创建套接字：在编写网络应用程序时，需要创建一个套接字，以便应用程序能够通过网络发送和接收数据。

- 绑定地址：在创建套接字后，需要将其绑定到本地地址和端口号上，以便其他计算机能够通过该地址和端口号找到应用程序。

- 监听连接请求：如果应用程序需要作为服务器，那么它需要监听连接请求，并等待客户端连接。

- 接受连接：一旦有客户端连接，服务器需要接受连接请求，并创建一个新的套接字来处理与该客户端之间的通信。

- 发送和接收数据：一旦连接建立，服务器和客户端就可以通过套接字进行数据的发送和接收。

- 关闭连接：在数据传输完成后，需要关闭连接以释放资源。
![image](https://user-images.githubusercontent.com/107925483/230305472-5be8f28f-5a02-4b1f-a860-40a86d24c5ee.png)

一个简单的TCP服务器并接受来自客户端的消息:  
``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main() {
    int server_fd, new_socket, valread;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    const char* message = "Hello from server";

    // 创建服务器端套接字
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置套接字选项，防止地址被占用
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址和端口
    address.sin_family = AF_INET; // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // 任意本地地址
    address.sin_port = htons(8080); // 端口号

    // 将套接字绑定到指定的地址和端口
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // 监听连接请求，最多允许 3 个客户端连接
    if (listen(server_fd, 3) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }

    // 等待客户端连接
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept failed");
        exit(EXIT_FAILURE);
    }

    // 发送欢迎消息给客户端
    send(new_socket, message, strlen(message), 0);

    // 读取客户端发送的消息
    valread = read(new_socket, buffer, 1024);
    printf("Client: %s\n", buffer);

    // 关闭连接
    close(new_socket);
    close(server_fd);

    return 0;
}
/*
server_fd 是服务器端套接字的文件描述符，用于监听客户端连接请求和接受连接。在程序中，server_fd 通过调用 socket() 函数创建，并使用 bind() 函数将套接字绑定到指定的地址和端口上。

new_socket 是客户端套接字的文件描述符，用于与客户端进行通信。在程序中，当有客户端连接到服务器时，accept() 函数会创建一个新的套接字，new_socket 通过这个新的套接字来与客户端之间进行通信，而 server_fd 仍然保持用于监听其他客户端的连接请求。在程序中，new_socket 是通过 accept() 函数返回的。
*/
```
![image](https://user-images.githubusercontent.com/107925483/230306196-e679546a-1325-4cc7-8290-cf7221c362a9.png)

TCP客户端连接服务器并发送消息：
``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char const *argv[]) {
    int sock = 0, valread;
    struct sockaddr_in serv_addr;
    char buffer[1024] = {0};
    const char* message = "Hello from client";

    // 创建客户端套接字
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址和端口
    serv_addr.sin_family = AF_INET; // IPv4
    serv_addr.sin_port = htons(8080); // 端口号

    // 将 IP 地址从字符串转换为二进制格式
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        perror("invalid address");
        exit(EXIT_FAILURE);
    }

    // 连接服务器
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("connection failed");
        exit(EXIT_FAILURE);
    }

    // 发送消息给服务器
    send(sock, message, strlen(message), 0);
    printf("Message sent: %s\n", message);

    // 读取服务器发送的消息
    valread = read(sock, buffer, 1024);
    printf("Server: %s\n", buffer);

    // 关闭连接
    close(sock);

    return 0;
}

```
