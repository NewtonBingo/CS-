## 套接字
套接字编程是一种网络编程技术，它可以让程序在不同的计算机之间进行通信。套接字编程的原理可以总结为以下几点：

- 创建套接字：在编写网络应用程序时，需要创建一个套接字，以便应用程序能够通过网络发送和接收数据。

- 绑定地址：在创建套接字后，需要将其绑定到本地地址和端口号上，以便其他计算机能够通过该地址和端口号找到应用程序。

- 监听连接请求：如果应用程序需要作为服务器，那么它需要监听连接请求，并等待客户端连接。

- 接受连接：一旦有客户端连接，服务器需要接受连接请求，并创建一个新的套接字来处理与该客户端之间的通信。

- 发送和接收数据：一旦连接建立，服务器和客户端就可以通过套接字进行数据的发送和接收。

- 关闭连接：在数据传输完成后，需要关闭连接以释放资源。
![image](https://user-images.githubusercontent.com/107925483/230305472-5be8f28f-5a02-4b1f-a860-40a86d24c5ee.png)

一个简单的TCP服务器并接受来自客户端的消息:  
``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

int main() {
    int server_fd, new_socket, valread;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};
    const char* message = "Hello from server";

    // 创建服务器端套接字
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置套接字选项，防止地址被占用
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址和端口
    address.sin_family = AF_INET; // IPv4
    address.sin_addr.s_addr = INADDR_ANY; // 任意本地地址
    address.sin_port = htons(8080); // 端口号

    // 将套接字绑定到指定的地址和端口
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // 监听连接请求，最多允许 3 个客户端连接
    if (listen(server_fd, 3) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }

    // 等待客户端连接
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("accept failed");
        exit(EXIT_FAILURE);
    }

    // 发送欢迎消息给客户端
    send(new_socket, message, strlen(message), 0);

    // 读取客户端发送的消息
    valread = read(new_socket, buffer, 1024);
    printf("Client: %s\n", buffer);

    // 关闭连接
    close(new_socket);
    close(server_fd);

    return 0;
}
/*
server_fd 是服务器端套接字的文件描述符，用于监听客户端连接请求和接受连接。在程序中，server_fd 通过调用 socket() 函数创建，并使用 bind() 函数将套接字绑定到指定的地址和端口上。

new_socket 是客户端套接字的文件描述符，用于与客户端进行通信。在程序中，当有客户端连接到服务器时，accept() 函数会创建一个新的套接字，new_socket 通过这个新的套接字来与客户端之间进行通信，而 server_fd 仍然保持用于监听其他客户端的连接请求。在程序中，new_socket 是通过 accept() 函数返回的。
*/
```
![image](https://user-images.githubusercontent.com/107925483/230306196-e679546a-1325-4cc7-8290-cf7221c362a9.png)

TCP客户端连接服务器并发送消息：
``` c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main(int argc, char const *argv[]) {
    int sock = 0, valread;
    struct sockaddr_in serv_addr;
    char buffer[1024] = {0};
    const char* message = "Hello from client";

    // 创建客户端套接字
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // 设置服务器地址和端口
    serv_addr.sin_family = AF_INET; // IPv4
    serv_addr.sin_port = htons(8080); // 端口号

    // 将 IP 地址从字符串转换为二进制格式
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        perror("invalid address");
        exit(EXIT_FAILURE);
    }

    // 连接服务器
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        perror("connection failed");
        exit(EXIT_FAILURE);
    }

    // 发送消息给服务器
    send(sock, message, strlen(message), 0);
    printf("Message sent: %s\n", message);

    // 读取服务器发送的消息
    valread = read(sock, buffer, 1024);
    printf("Server: %s\n", buffer);

    // 关闭连接
    close(sock);

    return 0;
}

```
## 网络编程模型
### 一些概念
#### 阻塞和非阻塞（调用者）
- 阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；
- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程；
- 两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。阻塞是指调用方一直在等待而且别的事情什么都不做；非阻塞是指调用方先去忙别的事情。
#### 同步与异步（被调用者）
- 同步处理是指被调用方得到最终结果之后才返回给调用方；
- 异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。
#### 一个输入操作通常包括两个不同的阶段
- 等待数据准备好；
- 从内核向进程复制数据。
- 对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。
调用方式，说的是阻塞和非阻塞；处理方式，说的是同步和异步
### I/O模型1：阻塞式 I/O 模型(blocking I/O）
![image](https://user-images.githubusercontent.com/107925483/230311268-b14b807a-e369-46cd-879f-4d475ab80236.png)
- 比喻：一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等。
- 优点：程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用CPU资源。
- 缺点：每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。
### I/O模型2：非阻塞式 I/O 模型(non-blocking I/O）
![image](https://user-images.githubusercontent.com/107925483/230311746-69fa1ef6-b09a-4a5a-b527-8ca389b781c8.png)
- 比喻：边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆。
- 优点：不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。
- 缺点：轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。
### I/O模型3：I/O 复用模型(I/O multiplexing）
![image](https://user-images.githubusercontent.com/107925483/230312197-3ffba5ca-c2d3-4e18-b44a-bdaf855b32e9.png)
同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。 
- 比喻：放了一堆鱼竿，在岸边一直守着这堆鱼竿，没鱼上钩就玩手机。
- 优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。
- 缺点：当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。
### I/O模型4：信号驱动式 I/O 模型（signal-driven I/O)
![image](https://user-images.githubusercontent.com/107925483/230313028-097e46c2-b72d-4997-9ace-c3048d76f9b2.png)
- 比喻：鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机。
- 优点：线程并没有在等待数据时被阻塞，可以提高资源的利用率。
- 缺点：信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。
对于 TCP 而言，信号驱动的 I/O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失。
### I/O模型5：异步 I/O 模型（即AIO，全称asynchronous I/O）
![image](https://user-images.githubusercontent.com/107925483/230313613-38743490-f214-47e3-8ab7-9cacce346f7d.png)
- 优点：异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。
- 缺点：要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。
![image](https://user-images.githubusercontent.com/107925483/230313987-4144746e-ba5b-4598-8161-7624698b94c2.png)
