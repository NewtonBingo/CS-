## C++代码风格
``` c++
#include <iostream>
#include <memory> // 智能指针头文件

using namespace std;

class Animal {
public:
  // 构造函数，用const引用初始化成员变量
  Animal(const std::string& name) : name_(name) {
    std::cout << "Create an Animal named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  virtual ~Animal() {
    std::cout << "Destroy Animal named " << name_ << std::endl;
  }

  // 纯虚函数，用于派生类的实现
  virtual void MakeSound() const = 0;

  // const成员函数，表示函数不会修改成员变量
  const std::string& GetName() const {
    return name_;
  }

protected:
  std::string name_;
};

class Dog : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Dog(const std::string& name) : Animal(name) {
    std::cout << "Create a Dog named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Dog() override {
    std::cout << "Destroy Dog named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Woof!" << std::endl;
  }
};

class Cat : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Cat(const std::string& name) : Animal(name) {
    std::cout << "Create a Cat named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Cat() override {
    std::cout << "Destroy Cat named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Meow!" << std::endl;
  }
};

class AnimalShelter {
public:
  // 静态成员函数，返回AnimalShelter类的单例对象
  static AnimalShelter& GetInstance() {
    static AnimalShelter instance; // 在函数内部定义静态局部变量，保证只创建一次
    return instance;
  }

  // 添加动物到动物收容所
  void AddAnimal(std::unique_ptr<Animal> animal) {
    animals_.emplace_back(std::move(animal));
  }

  // 显示所有动物的名称和声音
  void ListAllAnimals() const {
    for (const auto& animal : animals_) {
      std::cout << animal->GetName() << ": ";
      animal->MakeSound();
    }
  }

private:
  // 构造函数和析构函数私有化，禁止外访问此类的构造函数和析构函数
  AnimalShelter() {
    std::cout << "Create an AnimalShelter" << std::endl;
  }
  ~AnimalShelter() {
    std::cout << "Destroy AnimalShelter" << std::endl;
  }

  // 成员变量，用于存储动物指针
  std::vector<std::unique_ptr<Animal>> animals_;
};

int main() {
  AnimalShelter& shelter = AnimalShelter::GetInstance(); // 获得AnimalShelter类的单例对象

  // 创建不同种类的动物，并添加到动物收容所
  std::unique_ptr<Dog> dog = std::make_unique<Dog>("Fido");
  shelter.AddAnimal(std::move(dog));
  std::unique_ptr<Cat> cat = std::make_unique<Cat>("Fluffy");
  shelter.AddAnimal(std::move(cat));

  // 显示所有动物的名称和声音
  shelter.ListAllAnimals();

  // 可以看到，对象销毁时析构函数会被调用
  return 0;
}
```

注释和解释：

- 静态成员函数 `AnimalShelter::GetInstance()` 返回 `AnimalShelter` 类的单例对象。由于在函数内部定义了一个静态局部变量 `instance`，因此该对象的创建只会在第一次调用该函数时进行。
- `Animal` 类是一个抽象基类，它的成员函数 `MakeSound()` 是纯虚函数，必须由派生类进行实现。因此 `Animal` 类不能直接被实例化，只能用于派生新的动物种类。
- `Dog` 和 `Cat` 类都是 `Animal` 类的派生类。它们都实现了 `MakeSound()` 函数，以实现它们自己的声音。在它们的构造函数中，首先调用了基类构造函数 `Animal(name)`，来初始化 `name_` 成员变量。
- `AnimalShelter` 类用于管理动物，它的成员变量 `animals_` 是一个存储智能指针的向量，用于存储所有动物的指针。`AddAnimal()` 函数将新的动物添加到 `animals_` 向量中。`ListAllAnimals()` 函数则遍历 `animals_` 向量，打印每个动物的名称和声音。
- 在 `main()` 函数中，首先获取 `AnimalShelter` 类的单例对象 `shelter`。然后，创建一个名为 "Fido" 的狗和一个名为 "Fluffy" 的猫，并将它们添加到 `shelter` 中。最后，调用 `shelter.ListAllAnimals()` 显示所有动物的名称和声音。
- 由于使用了智能指针，不需要手动释放内存，因为当动物收容所 `shelter` 被销毁时，它的析构函数会自动销毁 `animals_` 中的所有动物。此外，在 `Animal` 类和 `AnimalShelter` 类中都使用了 `const` 成员函数

## 工程实践的一些用法
### 使用头文件保护宏
头文件保护宏可以防止头文件被重复包含，避免出现重复定义的错误。例如：  
``` c++
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 在此处编写头文件内容

#endif // MY_HEADER_H
```
### 使用命名空间
命名空间可以避免全局命名冲突的问题，使代码更加模块化和可维护。例如：  
``` c++
namespace my_namespace {
  // 在此处编写代码
}
```
### 使用静态断言
静态断言可以在编译时检查条件是否成立，避免在运行时才发现错误。例如：  
``` c++
#include <type_traits>

template<typename T>
void my_function(T value) {
  static_assert(std::is_integral<T>::value, "T必须是整数类型");
  // 在此处进行操作
}

```
### 使用预编译头文件
预编译头文件可以提高编译速度，避免重复编译相同的头文件。例如：  
``` c++
// 在pch.h中编写需要预编译的头文件内容
#include <iostream>
#include <vector>
#include <string>

// 在cpp文件中引用预编译头文件
#include "pch.h"

// 在此处编写代码
```
### 使用内联函数
内联函数可以减少函数调用的开销，提高代码执行效率。例如：  
``` c++
inline int add(int a, int b) {
  return a + b;
}

int main() {
  int result = add(1, 2);
  // result现在是3
  return 0;
}

```
### 使用模板和泛型编程
模板和泛型编程可以实现代码的复用和通用性，提高代码的灵活性。例如：  
``` c++
template<typename T>
void my_function(T value) {
  // 在此处进行操作
}

int main() {
  my_function(1);
  my_function("hello");
  return 0;
}

```
### 使用工厂模式
工厂模式可以隐藏对象的创建细节，提供统一的接口来创建对象。例如：
``` c++
class Animal {
public:
  virtual void say() = 0;
};

class Cat : public Animal {
public:
  void say() {
    std::cout << "喵喵喵" << std::endl;
  }
};

class Dog : public Animal {
public:
  void say() {
    std::cout << "汪汪汪" << std::endl;
  }
};

class AnimalFactory {
public:
  static Animal* createAnimal(int type) {
    switch(type) {
      case 1: return new Cat();
      case 2: return new Dog();
      default: return nullptr;
    }
  }
};
 
int main() {
  Animal* cat = AnimalFactory::createAnimal(1);
  Animal* dog = AnimalFactory::createAnimal(2);

  cat->say(); // 输出 "喵喵喵"
  dog->say(); // 输出 "汪汪汪"

  delete cat;
  delete dog;

  return 0;
}
```
### 使用RAII（资源获取即初始化）技术
RAII技术可以确保资源的正确释放，避免资源泄漏和错误释放。例如：

```c++
class MyFile {
public:
  MyFile(std::string filename) {
    file_ = fopen(filename.c_str(), "r");
  }

  ~MyFile() {
    if (file_) {
      fclose(file_);
    }
  }

  // 省略了一些读取文件内容的方法

private:
  FILE* file_;
};

int main() {
  MyFile file("example.txt");
  // 在此处进行文件操作

  return 0;
}
```
以上是一些C++在工程上常用的编程技巧，它们可以提高代码的可维护性、可读性和效率。但需要注意的是，技巧只是工具，合理的应用才能真正发挥其价值。
