## C++代码风格
``` c++
#include <iostream>
#include <memory> // 智能指针头文件

using namespace std;

class Animal {
public:
  // 构造函数，用const引用初始化成员变量
  Animal(const std::string& name) : name_(name) {
    std::cout << "Create an Animal named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  virtual ~Animal() {
    std::cout << "Destroy Animal named " << name_ << std::endl;
  }

  // 纯虚函数，用于派生类的实现
  virtual void MakeSound() const = 0;

  // const成员函数，表示函数不会修改成员变量
  const std::string& GetName() const {
    return name_;
  }

protected:
  std::string name_;
};

class Dog : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Dog(const std::string& name) : Animal(name) {
    std::cout << "Create a Dog named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Dog() override {
    std::cout << "Destroy Dog named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Woof!" << std::endl;
  }
};

class Cat : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Cat(const std::string& name) : Animal(name) {
    std::cout << "Create a Cat named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Cat() override {
    std::cout << "Destroy Cat named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Meow!" << std::endl;
  }
};

class AnimalShelter {
public:
  // 静态成员函数，返回AnimalShelter类的单例对象
  static AnimalShelter& GetInstance() {
    static AnimalShelter instance; // 在函数内部定义静态局部变量，保证只创建一次
    return instance;
  }

  // 添加动物到动物收容所
  void AddAnimal(std::unique_ptr<Animal> animal) {
    animals_.emplace_back(std::move(animal));
  }

  // 显示所有动物的名称和声音
  void ListAllAnimals() const {
    for (const auto& animal : animals_) {
      std::cout << animal->GetName() << ": ";
      animal->MakeSound();
    }
  }

private:
  // 构造函数和析构函数私有化，禁止外访问此类的构造函数和析构函数
  AnimalShelter() {
    std::cout << "Create an AnimalShelter" << std::endl;
  }
  ~AnimalShelter() {
    std::cout << "Destroy AnimalShelter" << std::endl;
  }

  // 成员变量，用于存储动物指针
  std::vector<std::unique_ptr<Animal>> animals_;
};

int main() {
  AnimalShelter& shelter = AnimalShelter::GetInstance(); // 获得AnimalShelter类的单例对象

  // 创建不同种类的动物，并添加到动物收容所
  std::unique_ptr<Dog> dog = std::make_unique<Dog>("Fido");
  shelter.AddAnimal(std::move(dog));
  std::unique_ptr<Cat> cat = std::make_unique<Cat>("Fluffy");
  shelter.AddAnimal(std::move(cat));

  // 显示所有动物的名称和声音
  shelter.ListAllAnimals();

  // 可以看到，对象销毁时析构函数会被调用
  return 0;
}
```
