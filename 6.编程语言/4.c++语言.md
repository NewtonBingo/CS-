## C++代码风格
``` c++
#include <iostream>
#include <memory> // 智能指针头文件

using namespace std;

class Animal {
public:
  // 构造函数，用const引用初始化成员变量
  Animal(const std::string& name) : name_(name) {
    std::cout << "Create an Animal named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  virtual ~Animal() {
    std::cout << "Destroy Animal named " << name_ << std::endl;
  }

  // 纯虚函数，用于派生类的实现
  virtual void MakeSound() const = 0;

  // const成员函数，表示函数不会修改成员变量
  const std::string& GetName() const {
    return name_;
  }

protected:
  std::string name_;
};

class Dog : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Dog(const std::string& name) : Animal(name) {
    std::cout << "Create a Dog named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Dog() override {
    std::cout << "Destroy Dog named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Woof!" << std::endl;
  }
};

class Cat : public Animal {
public:
  // 构造函数，调用基类构造函数来初始化成员变量
  Cat(const std::string& name) : Animal(name) {
    std::cout << "Create a Cat named " << name_ << std::endl;
  }

  // 虚析构函数，用于多态的正确销毁对象
  ~Cat() override {
    std::cout << "Destroy Cat named " << name_ << std::endl;
  }

  // 重载基类虚函数，实现自己的功能
  void MakeSound() const override {
    std::cout << "Meow!" << std::endl;
  }
};

class AnimalShelter {
public:
  // 静态成员函数，返回AnimalShelter类的单例对象
  static AnimalShelter& GetInstance() {
    static AnimalShelter instance; // 在函数内部定义静态局部变量，保证只创建一次
    return instance;
  }

  // 添加动物到动物收容所
  void AddAnimal(std::unique_ptr<Animal> animal) {
    animals_.emplace_back(std::move(animal));
  }

  // 显示所有动物的名称和声音
  void ListAllAnimals() const {
    for (const auto& animal : animals_) {
      std::cout << animal->GetName() << ": ";
      animal->MakeSound();
    }
  }

private:
  // 构造函数和析构函数私有化，禁止外访问此类的构造函数和析构函数
  AnimalShelter() {
    std::cout << "Create an AnimalShelter" << std::endl;
  }
  ~AnimalShelter() {
    std::cout << "Destroy AnimalShelter" << std::endl;
  }

  // 成员变量，用于存储动物指针
  std::vector<std::unique_ptr<Animal>> animals_;
};

int main() {
  AnimalShelter& shelter = AnimalShelter::GetInstance(); // 获得AnimalShelter类的单例对象

  // 创建不同种类的动物，并添加到动物收容所
  std::unique_ptr<Dog> dog = std::make_unique<Dog>("Fido");
  shelter.AddAnimal(std::move(dog));
  std::unique_ptr<Cat> cat = std::make_unique<Cat>("Fluffy");
  shelter.AddAnimal(std::move(cat));

  // 显示所有动物的名称和声音
  shelter.ListAllAnimals();

  // 可以看到，对象销毁时析构函数会被调用
  return 0;
}
```

注释和解释：

- 静态成员函数 `AnimalShelter::GetInstance()` 返回 `AnimalShelter` 类的单例对象。由于在函数内部定义了一个静态局部变量 `instance`，因此该对象的创建只会在第一次调用该函数时进行。
- `Animal` 类是一个抽象基类，它的成员函数 `MakeSound()` 是纯虚函数，必须由派生类进行实现。因此 `Animal` 类不能直接被实例化，只能用于派生新的动物种类。
- `Dog` 和 `Cat` 类都是 `Animal` 类的派生类。它们都实现了 `MakeSound()` 函数，以实现它们自己的声音。在它们的构造函数中，首先调用了基类构造函数 `Animal(name)`，来初始化 `name_` 成员变量。
- `AnimalShelter` 类用于管理动物，它的成员变量 `animals_` 是一个存储智能指针的向量，用于存储所有动物的指针。`AddAnimal()` 函数将新的动物添加到 `animals_` 向量中。`ListAllAnimals()` 函数则遍历 `animals_` 向量，打印每个动物的名称和声音。
- 在 `main()` 函数中，首先获取 `AnimalShelter` 类的单例对象 `shelter`。然后，创建一个名为 "Fido" 的狗和一个名为 "Fluffy" 的猫，并将它们添加到 `shelter` 中。最后，调用 `shelter.ListAllAnimals()` 显示所有动物的名称和声音。
- 由于使用了智能指针，不需要手动释放内存，因为当动物收容所 `shelter` 被销毁时，它的析构函数会自动销毁 `animals_` 中的所有动物。此外，在 `Animal` 类和 `AnimalShelter` 类中都使用了 `const` 成员函数
