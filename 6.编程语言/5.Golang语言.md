``` golang
package main // Go程序入口必须在main包中

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// 定义一个全局变量
var globalVar int

// 定义一个结构体
type person struct {
	name string
	age  int
}

// 定义一个接口
type animal interface {
	speak() string
}

// 定义一个实现接口的结构体
type dog struct {
	name string
}

// 实现 animal 接口
func (d dog) speak() string {
	return "汪汪汪"
}

func main() {
	// 输出 Hello, World!
	fmt.Println("Hello, World!")

	// 定义变量
	var a int
	a = 10
	b := 20

	// 输出变量
	fmt.Printf("a = %d, b = %d\n", a, b)

	// 定义数组
	var arr [5]int
	arr[0] = 1
	arr[1] = 2
	arr[2] = 3
	arr[3] = 4
	arr[4] = 5

	// 输出数组
	fmt.Println(arr)

	// 定义切片
	slice := make([]int, 3, 5)
	slice[0] = 1
	slice[1] = 2
	slice[2] = 3

	// 输出切片
	fmt.Println(slice)

	// 定义 map
	m := make(map[string]int)
	m["one"] = 1
	m["two"] = 2

	// 输出 map
	fmt.Println(m)

	// 定义结构体
	p := person{
		name: "张三",
		age:  20,
	}

	// 输出结构体
	fmt.Println(p)

	// 定义接口变量
	var a1 animal
	d1 := dog{
		name: "旺财",
	}
	a1 = d1

	// 输出接口变量
	fmt.Println(a1.speak())

	// 定义 goroutine
	wg := sync.WaitGroup{}
	wg.Add(10)
	for i := 0; i < 10; i++ {
		go func(i int) {
			defer wg.Done()
			time.Sleep(time.Duration(rand.Intn(3)) * time.Second)
			fmt.Printf("goroutine %d 执行完成\n", i)
		}(i)
	}
	wg.Wait()

	// 定义 channel
	ch := make(chan int)
	go func() {
		ch <- 1
		ch <- 2
		ch <- 3
		close(ch)
	}()
	for i := range ch {
		fmt.Println(i)
	}

	// 定义错误类型
	err := fmt.Errorf("错误信息")
	if err != nil {
		fmt.Println(err)
	}

	// 定义 defer
	defer fmt.Println("最后执行的 defer")
	fmt.Println("函数执行完毕")
}

```

``` golang
package main // 声明包名

import (
    "fmt" // 导入标准库中的fmt包
)

const pi = 3.14 // 常量声明

var (
    name string // 变量声明
    age  int    // 变量声明
)

func main() { // 主函数
    name = "Bob" // 赋值语句
    age = 20     // 赋值语句

    if age < 18 { // if语句
        fmt.Println("You are not old enough")
    } else { // else语句
        fmt.Println("Welcome", name)
    }

    numbers := [5]int{1, 2, 3, 4, 5} // 数组声明
    for i := 0; i < len(numbers); i++ { // for循环
        fmt.Println(numbers[i])
    }

    colors := []string{"red", "green", "blue"} // 切片声明
    for index, value := range colors { // for range循环
        fmt.Println(index, value)
    }

    type person struct { // 结构体声明
        name string
        age  int
    }

    p := person{name: "Alice", age: 30} // 结构体实例化
    fmt.Println(p.name, "is", p.age, "years old")

    pointer := &p // 指针声明
    fmt.Println("Pointer to p:", pointer)

    go func() { // 并发执行
        fmt.Println("Hello from a goroutine")
    }()

    fmt.Println("Hello from main")
}

```
## 语言特点
Golang（或称为Go）是一种由Google开发的编程语言，它是一种开源的、快速的、静态类型的语言，旨在简化系统级编程和大规模并发处理。以下是Golang语言本身的一些优点和缺点以及相应的理由：  
### 优点
高效性：Golang是一种非常高效的编程语言，具有非常高的性能和速度，主要得益于其优秀的编译器和运行时系统。  

并发性：Golang旨在为大规模并发编程提供支持，它通过goroutines和channels提供了非常简单和优雅的并发编程模型。  

安全性：Golang内置了内存安全性和类型安全性等特性，避免了一些常见的安全问题，如缓冲区溢出等。    

简单性：Golang的语法非常简单，容易学习和理解，减少了代码的复杂性，从而提高了代码的可读性和可维护性。  

跨平台：Golang可以轻松地在不同的操作系统和架构上编译和运行，这使得它成为一个非常方便的跨平台编程语言。
### 缺点
依赖管理：Golang目前的依赖管理机制较为麻烦，需要手动下载和管理依赖包。  

重构问题：Golang的静态类型检查可能会在重构代码时造成一些麻烦，特别是在涉及到大量类型转换的情况下。  

限制性：Golang的一些设计特性可能会对一些高级编程模式造成限制，如泛型、函数式编程等。  

相对年轻：Golang是相对较年轻的编程语言，虽然它已经获得了广泛的使用，但它仍然缺乏一些成熟的库和框架。  

总之，Golang是一种非常强大、高效和易于学习的编程语言，它在大规模并发处理方面表现出色，并提供了良好的内存安全性和类型安全性。虽然它仍有一些局限性，但随着其在不同行业的广泛应用，Golang将会越来越成熟和强大。  

