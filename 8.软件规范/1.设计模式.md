## 设计模式分类
设计模式是一种被广泛使用的软件设计思想，用于解决特定的设计问题，是在软件开发中经过实践总结出来的可重用的经验。   

在软件开发中，设计模式可以帮助开发者通过已有的经验和思想来解决类似的问题，减少开发工作量和出现错误的概率，提高软件的可维护性和可扩展性。  

设计模式可以分为三种类型：  

创建型模式：用于创建对象的模式，包括工厂模式、抽象工厂模式、单例模式、原型模式和建造者模式等。  

结构型模式：用于描述如何组合类和对象以形成更大的结构，包括适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式和代理模式等。  

行为型模式：用于描述对象之间的通信方式和协作方式，包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式等。
## 创建型模式
### 单例模式
单例模式是一种常见的设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例，常用的场景：  
1.日志记录器：在一个应用程序中，只应该有一个日志记录器来记录所有的日志信息。  
2.数据库连接池：连接池是为了重用连接而创建的。但是，如果不加以限制，可能会创建大量连接，因此可以使用单例模式来确保只有一个连接池实例。  
3.系统配置：系统配置数据应该只有一个实例，因为它们的值应该在整个系统中是一致的。  
#### C语言实现
``` c
typedef struct {
    int value;
} Singleton;

Singleton* getSingletonInstance() {
    static Singleton instance = {0}; // 静态局部变量，用于存储唯一实例
    return &instance; // 返回唯一实例的指针
}
```
在上述示例中，我们定义了一个名为Singleton的结构体，其中包含一个整型成员变量value。我们还定义了一个名为getSingletonInstance()的函数，该函数用于获取该结构体的唯一实例。该函数内部定义了一个静态局部变量instance，用于存储唯一实例。由于静态局部变量只会在第一次调用函数时被初始化，因此该实例只会被创建一次。我们通过返回该实例的指针来实现单例模式。由于静态局部变量的生命周期与程序的生命周期相同，因此该实例会在程序结束时被自动销毁。  
需要注意的是，由于C语言中没有访问修饰符的概念，因此无法像C++那样将构造函数和析构函数私有化。因此，我们需要手动管理该实例的内存，以确保其唯一性和正确性。

#### C++实现
``` c++
class Singleton {
private:
    static Singleton* instance; // 唯一实例的静态指针 静态数据成员是在类定义中声明，在类外定义并初始化的
    Singleton() { } // 私有构造函数，防止外部实例化该类
public:
    static Singleton* getInstance() { // 全局访问点
        if (instance == nullptr) { // 如果实例尚未创建，则创建实例
            instance = new Singleton();
        }
        return instance; // 返回唯一实例的指针
    }
};

Singleton* Singleton::instance = nullptr; // 静态指针初始化为nullptr
/*
 * 在这个示例中，我们创建了一个名为 Singleton 的类，
 * 它包含一个静态成员 instance，它存储了唯一的 Singleton 实例。
 * getInstance() 方法返回该实例。如果实例尚未创建，则在第一次调用 getInstance() 方法时创建它。
 * 由于构造函数被私有化，因此无法从外部实例化该类。
 */

/*
 * 使用单例模式可以带来以下好处：
 * 1. 限制实例数量：单例模式确保只有一个实例存在，适用于需要限制实例数量的场景。
 * 2. 简化代码：单例模式可以简化代码，因为不需要在多个地方创建和管理实例。
 * 3. 提高性能：由于单例模式只创建一个实例，因此可以避免创建和销毁对象的开销，提高性能。
 */

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();

    if (s1 == s2) {
        std::cout << "Same instance" << std::endl;
    }
    else {
        std::cout << "Different instances" << std::endl;
    }

    return 0;
}

```

#### G语言实现
在Go语言中，我们可以使用sync.Once和匿名函数来实现单例模式。sync.Once是一个用于确保只执行一次操作的结构体，我们可以将实例创建操作放在匿名函数中，确保只会在第一次调用时被执行:  
``` golang
package main

import "sync"

type Singleton struct {
    value int
}

var instance *Singleton
var once sync.Once

func getSingletonInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{value: 0} // 创建唯一实例
    })
    return instance // 返回唯一实例的指针
}

func main() {
    s1 := getSingletonInstance()
    s2 := getSingletonInstance()
    if s1 == s2 {
        println("Same instance")
    } else {
        println("Different instances")
    }
}

```
在上述示例中，我们定义了一个名为Singleton的结构体，其中包含一个整型成员变量value。我们还定义了一个名为instance的全局变量，用于存储唯一实例。sync.Once是一个用于确保只执行一次操作的结构体，我们将实例创建操作放在匿名函数中，并将该匿名函数传递给sync.Once的Do方法。Do方法会在第一次调用时执行该匿名函数，而后续的调用则会直接返回已创建的实例。getSingletonInstance函数用于获取该结构体的唯一实例，通过返回该实例的指针来实现单例模式。  

在main函数中，我们调用getSingletonInstance函数两次，并将返回的实例指针分别存储在s1和s2变量中。通过判断s1和s2是否相等，我们可以验证该实例是否唯一。  

需要注意的是，由于Go语言中不存在全局变量的初始化顺序问题，因此我们无需显式地初始化instance变量。sync.Once会在第一次调用时执行匿名函数，因此该实例只会被创建一次。  
