## 设计模式分类
设计模式是一种被广泛使用的软件设计思想，用于解决特定的设计问题，是在软件开发中经过实践总结出来的可重用的经验。   

在软件开发中，设计模式可以帮助开发者通过已有的经验和思想来解决类似的问题，减少开发工作量和出现错误的概率，提高软件的可维护性和可扩展性。  

设计模式可以分为三种类型：  

创建型模式：用于创建对象的模式，包括工厂模式、抽象工厂模式、单例模式、原型模式和建造者模式等。  

结构型模式：用于描述如何组合类和对象以形成更大的结构，包括适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式和代理模式等。  

行为型模式：用于描述对象之间的通信方式和协作方式，包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式等。
## 创建型模式
### 单例模式
单例模式是一种常见的设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例，常用的场景：  
1.日志记录器：在一个应用程序中，只应该有一个日志记录器来记录所有的日志信息。  
2.数据库连接池：连接池是为了重用连接而创建的。但是，如果不加以限制，可能会创建大量连接，因此可以使用单例模式来确保只有一个连接池实例。  
3.系统配置：系统配置数据应该只有一个实例，因为它们的值应该在整个系统中是一致的。  
#### C语言实现
``` c
typedef struct {
    int value;
} Singleton;

Singleton* getSingletonInstance() {
    static Singleton instance = {0}; // 静态局部变量，用于存储唯一实例
    return &instance; // 返回唯一实例的指针
}
```
在上述示例中，我们定义了一个名为Singleton的结构体，其中包含一个整型成员变量value。我们还定义了一个名为getSingletonInstance()的函数，该函数用于获取该结构体的唯一实例。该函数内部定义了一个静态局部变量instance，用于存储唯一实例。由于静态局部变量只会在第一次调用函数时被初始化，因此该实例只会被创建一次。我们通过返回该实例的指针来实现单例模式。由于静态局部变量的生命周期与程序的生命周期相同，因此该实例会在程序结束时被自动销毁。  
需要注意的是，由于C语言中没有访问修饰符的概念，因此无法像C++那样将构造函数和析构函数私有化。因此，我们需要手动管理该实例的内存，以确保其唯一性和正确性。

#### C++语言实现
``` c++
class Singleton {
private:
    static Singleton* instance; // 唯一实例的静态指针 静态数据成员是在类定义中声明，在类外定义并初始化的
    Singleton() { } // 私有构造函数，防止外部实例化该类
public:
    static Singleton* getInstance() { // 全局访问点
        if (instance == nullptr) { // 如果实例尚未创建，则创建实例
            instance = new Singleton();
        }
        return instance; // 返回唯一实例的指针
    }
};

Singleton* Singleton::instance = nullptr; // 静态指针初始化为nullptr
/*
 * 在这个示例中，我们创建了一个名为 Singleton 的类，
 * 它包含一个静态成员 instance，它存储了唯一的 Singleton 实例。
 * getInstance() 方法返回该实例。如果实例尚未创建，则在第一次调用 getInstance() 方法时创建它。
 * 由于构造函数被私有化，因此无法从外部实例化该类。
 */

/*
 * 使用单例模式可以带来以下好处：
 * 1. 限制实例数量：单例模式确保只有一个实例存在，适用于需要限制实例数量的场景。
 * 2. 简化代码：单例模式可以简化代码，因为不需要在多个地方创建和管理实例。
 * 3. 提高性能：由于单例模式只创建一个实例，因此可以避免创建和销毁对象的开销，提高性能。
 */

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();

    if (s1 == s2) {
        std::cout << "Same instance" << std::endl;
    }
    else {
        std::cout << "Different instances" << std::endl;
    }

    return 0;
}

```

#### Go语言实现
在Go语言中，我们可以使用sync.Once和匿名函数来实现单例模式。sync.Once是一个用于确保只执行一次操作的结构体，我们可以将实例创建操作放在匿名函数中，确保只会在第一次调用时被执行:  
``` golang
package main

import "sync"

type Singleton struct {
    value int
}

var instance *Singleton
var once sync.Once

func getSingletonInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{value: 0} // 创建唯一实例
    })
    return instance // 返回唯一实例的指针
}

func main() {
    s1 := getSingletonInstance()
    s2 := getSingletonInstance()
    if s1 == s2 {
        println("Same instance")
    } else {
        println("Different instances")
    }
}

```
在上述示例中，我们定义了一个名为Singleton的结构体，其中包含一个整型成员变量value。我们还定义了一个名为instance的全局变量，用于存储唯一实例。sync.Once是一个用于确保只执行一次操作的结构体，我们将实例创建操作放在匿名函数中，并将该匿名函数传递给sync.Once的Do方法。Do方法会在第一次调用时执行该匿名函数，而后续的调用则会直接返回已创建的实例。getSingletonInstance函数用于获取该结构体的唯一实例，通过返回该实例的指针来实现单例模式。  

在main函数中，我们调用getSingletonInstance函数两次，并将返回的实例指针分别存储在s1和s2变量中。通过判断s1和s2是否相等，我们可以验证该实例是否唯一。  

需要注意的是，由于Go语言中不存在全局变量的初始化顺序问题，因此我们无需显式地初始化instance变量。sync.Once会在第一次调用时执行匿名函数，因此该实例只会被创建一次。  

### 工厂模式
工厂模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。工厂模式通过将对象的创建委托给一个工厂类来实现，从而使得客户端代码可以与具体类解耦。  

工厂模式包括四个核心组件：抽象工厂、具体工厂、抽象产品和具体产品。抽象工厂是一个接口，定义了创建产品的方法。具体工厂是实现抽象工厂接口的类，负责创建具体产品对象。抽象产品是一个接口，定义了产品的属性和方法。具体产品是实现抽象产品接口的类，提供了具体的实现细节。  

**工厂模式适用于以下场景：**  
<ol>
<li>需要创建一系列相互依赖的对象，并且需要统一管理它们的创建过程。</li> 
<li>需要对客户端隐藏对象的创建细节，客户端只需要知道产品的接口。</li>  
<li>需要在运行时动态决定创建哪些具体产品对象。</li>  
<li>需要将产品的创建和使用解耦，避免客户端代码和具体产品实现之间的直接依赖关系。</li> 
</ol>

**以下是一些常见的应用场景：**
<ol>
<li>日志记录器工厂：在应用程序中创建不同类型的日志记录器，如控制台日志记录器、文件日志记录器、数据库日志记录器等。</li>  
<li>图形界面控件工厂：在图形界面应用程序中创建不同类型的控件，如按钮、文本框、下拉框等。</li>  
<li>数据库连接池工厂：在应用程序中创建和管理数据库连接池，提高数据库访问效率。</li>  
<li>加密算法工厂：在应用程序中创建和管理加密算法，提高数据安全性。</li>
</ol>
 
总之，工厂模式可以在需要创建大量对象的场景中帮助我们提高代码的可维护性和可扩展性，同时还能帮助我们避免代码中出现大量的 if-else 或 switch-case 分支判断，提高代码的可读性和可维护性。
#### C++实现
``` c++
#include <iostream>

// 抽象产品类
class Product {
public:
    virtual ~Product() {}
    virtual void operation() = 0;
};

// 具体产品类 A
class ProductA : public Product {
public:
    void operation() override {
        std::cout << "Product A operation." << std::endl;
    }
};

// 具体产品类 B
class ProductB : public Product {
public:
    void operation() override {
        std::cout << "Product B operation." << std::endl;
    }
};

// 工厂类
class Factory {
public:
    virtual ~Factory() {}
    virtual Product* createProduct() = 0;
};

// 具体工厂类 A
class FactoryA : public Factory {
public:
    Product* createProduct() override {
        return new ProductA();
    }
};

// 具体工厂类 B
class FactoryB : public Factory {
public:
    Product* createProduct() override {
        return new ProductB();
    }
};

int main() {
    // 创建工厂对象
    Factory* factoryA = new FactoryA();
    Factory* factoryB = new FactoryB();

    // 使用工厂对象创建产品对象
    Product* productA = factoryA->createProduct();
    Product* productB = factoryB->createProduct();

    // 使用产品对象
    productA->operation();  // 输出：Product A operation.
    productB->operation();  // 输出：Product B operation.

    // 释放资源
    delete productA;
    delete productB;
    delete factoryA;
    delete factoryB;

    return 0;
}

/*
在上面的示例中，我们定义了一个抽象产品类 Product，该类定义了所有具体产品类所具有的公共接口 operation。
然后，我们定义了两个具体产品类 ProductA 和 ProductB，它们分别实现了抽象产品类中定义的接口。
接着，我们定义了一个工厂类 Factory，该类定义了创建产品对象的公共接口 createProduct。
然后，我们分别定义了两个具体工厂类 FactoryA 和 FactoryB，它们分别实现了工厂类中定义的接口，并负责根据客户端的请求来创建具体的产品对象，并返回该对象的指针或引用。
在客户端代码中，我们先创建了两个工厂对象 factoryA 和 factoryB，它们分别用来创建不同类型的产品对象。
然后，我们使用工厂对象创建具体的产品对象 productA 和 productB，并使用产品对象的接口 operation 来执行具体的业务逻辑。
最后，我们释放了创建的对象的资源，避免内存泄漏。
*/
```
